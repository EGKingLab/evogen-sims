// Mimic constant, constant model

initialize() {

	// neutral mutations
	initializeMutationRate(0);
	initializeMutationType("m1", 0.5, "f", 0.0);      
	initializeGenomicElementType("g1", m1, 1.0);
	
	// mutations in QTLs
	// set equal proportion to neutral (GenomicElement..)
	scriptQTL = "rexp(1);";
	initializeMutationType("m2", 0.5, "s", scriptQTL);  // QTL
	initializeGenomicElementType("g2", m2, 1.0);
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "l";
	
	
	
	// set up our chromosome: N QTLs, surrounded by neutral regions
   defineConstant("C", 100);    // number of QTLs
   defineConstant("W", 1000);  // size of neutral buffer on each side
   pos = 0;
	q = NULL;
		for (i in 1:C)
			{
            initializeGenomicElement(g1, pos, pos + W-1);
            pos = pos + W;
            initializeGenomicElement(g2, pos, pos);
            q = c(q, pos);
            pos = pos + 1;
            initializeGenomicElement(g1, pos, pos + W-1);
				pos = pos + W; 
				}
	defineConstant("Q", q);     // remember our QTL positions
     
         // we want the QTLs to be unlinked; build a recombination map for that
         //rates = c(rep(c(1e-8, 0.5), C-1), 1e-8);
         //ends = (repEach(Q + W, 2) + rep(c(0,1), C))[0:(C*2 - 2)];
         //initializeRecombinationRate(rates, ends);
	initializeRecombinationRate(1e-8);   
}


1 {
 // create all mutations in a genome in a dummy subpopulation
    sim.addSubpop("p2", 1);
    g = p2.genomes[0];
    muts = g.addNewMutation(m2, rexp(100), Q);

	sim.addSubpop("p1", 10000);
	marks = runif(100, 0,1);
	ind = 0;
	for(qpos in Q)
	{
		for(g in p1.genomes)
		{
		if(rbinom(1,1,marks[ind])==1){g.addMutations(muts[ind]);}
		}
		ind = ind + 1;
	}
	 // remove the dummy subpopulation
         p2.setSubpopulationSize(0);
} 

1 late(){
	qtls = sim.mutationsOfType(m2);
	f = sim.mutationFrequencies(NULL, qtls);
	s = qtls.selectionCoeff;
	p = qtls.position;
	o = qtls.originGeneration;
	indices = order(o, F);
	cat(sim.generation, "\n");
	
	// sum the additive effects of QTLs
	defineConstant("h2", 0.5);
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	// model environmental variance, according to the target heritability
	V_A = sd(additive)^2;
	defineConstant("V_E",(V_A - h2 * V_A) / h2);    // from h2 == V_A / (V_A + V_E)
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	phenotypes = additive + env;
	
	// get new mean 4 sd away
	defineConstant("newopt", mean(phenotypes) + sd(phenotypes)*4);		
	
	cat("VA " + V_A + "\n");
	cat("newopt" + newopt + "\n");


}


2:500 late() {
	// sum the additive effects of QTLs
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	// model environmental variance, according to the target heritability
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	phenotypes = additive + env;
	//cat(phenotypes + "\n");
	//inds.fitnessScaling = 1 + dnorm(newopt-phenotypes,0,0.25);
	inds.fitnessScaling = 1-(abs(phenotypes - newopt)/200);
	//1.0 + dnorm(100 - phenotypes, 0.0, 5.0);
	inds.tagF = phenotypes;

}
fitness(m2) {
	return 1.0;   // QTLs are neutral; fitness effects are handled below
}

501 late() {
	cat("\n\n-------------------------------\n");
	cat("QTLs at generation " + sim.generation + ":\n\n");
	
	qtls = sim.mutationsOfType(m2);
	f = sim.mutationFrequencies(NULL, qtls);
	s = qtls.selectionCoeff;
	p = qtls.position;
	o = qtls.originGeneration;
	indices = order(f, F);
	
	for (i in indices)
		cat("   " + p[i] + ": s = " + s[i] + ", f == " + f[i] + ", o == " + o[i] + "\n");
	
	sim.simulationFinished();
}
