
initialize(){
	// Set seed and SLiM options
	setSeed(2345);
	initializeSLiMOptions(keepPedigrees=T);
	
	// Define constants and mutation types
	
	initializeSex("A");
	
	defineConstant("X_me", 1e06);
	defineConstant("slocus", 5e5);
	initializeMutationRate(0);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1);
	
	// Define script for QTLs and initialize genomic element types
	scriptForQTLs = "rexp(1);";
	initializeMutationType("m2", 0.5, "s", scriptForQTLs);
	initializeGenomicElementType("g2", m2, 1);
	initializeGenomicElement(g1, 0, slocus - 1);
	initializeGenomicElement(g2, slocus, slocus);
	initializeGenomicElement(g1, slocus + 1, X_me);
	
	// Define Q and recombination rate
	q = c(NULL, slocus);
	defineConstant("Q", q);
	initializeRecombinationRate(1e-8);
	
	// Set colors for mutation types
	m1.color = "blue";
	m2.color = "red";
}

// Initial generation
	1 early() {
	// Add a subpopulation for individuals that will be used for selecting QTLs
	sim.addSubpop("p2", 2);
	// Add a mutation of type m2 to the first genome in subpopulation p2
	g = p2.genomes[0];
	muts = g.addNewMutation(m2, rexp(1), Q);
	// Add a subpopulation of individuals that will be used for the main simulation
	sim.addSubpop("p1", 10000);
	// Assign each individual in p1 a probability of carrying the QTL mutation based on a random marker
	markers = runif(1);
	ind = 0;
	for (position in Q){
		for (g in p1.genomes){
			if(rbinom(1,1, markers[ind]) == 1){g.addMutations(muts[ind]);}
		}
		ind = ind + 1;
	}
	// Set the size of the selecting population to 0
	p2.setSubpopulationSize(0);
	// Set the sex ratio of the main population to 0.5
	p1.setSexRatio(0.5);
	// Set the cloning rate of the main population to 0
	p1.setCloningRate(0);
	// Set the selfing rate of the main population to 0
	p1.setSelfingRate(0);
	
	// Create CSV file for genome data and mean phenotype data
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/genome_singl",".csv"), paste0("Generation,Position,Frequency,Effect,Heterozygosity,origin"));
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/MeanPhenotypes_singl",".csv"), paste0("Generation,meanFitness,Phenotype,Optimum"));
}

// Function to calculate mutation effect
mutationEffect(m2) {
	return 1.0;
}

// Late generations
// Define the heritability constant h2 and get the sum of all additive mutations
1 late() {
	defineConstant("h2", 0.5);
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	// Calculate the genetic variance and define the environmental variance
	V_A = sd(additive)^2;
	defineConstant("V_E",(V_A/h2)- V_A);
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// Calculate the phenotypes by adding the genetic and environmental components
	phenotypes = additive + env;
	
	// Define the lower and upper bounds of the optimal phenotype and define a global variable newopt
	lower_opt = mean(phenotypes) + sd(phenotypes)*2;
	upper_opt = mean(phenotypes) + sd(phenotypes)*2;
	nopt = rep(c(rep(lower_opt ,25),rep(upper_opt,25)), 21);
	defineGlobal("newopt", nopt);
	
	// Get the mutation information and order them by frequency
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	het = calcHeterozygosity(p1.genomes);
	indices = order(freq, F);
	
	// Write mutation information to a CSV file
	for (i in indices)
		writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/genome_singl",".csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",",format("%.6f",het[i]), ",", origin[i]), append = T);
	
	// Get the mean phenotype and write it to a CSV file
	meanPhenotype = mean(phenotypes);
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/MeanPhenotypes_singl",".csv"), paste0(sim.cycle,",", 1, ",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);
	sim.outputFull("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/ped_file.csv");

}

// Implement the selection process for generations 2 to 500

2:500 late(){
	// Get individuals in the population
	inds = sim.subpopulations.individuals;
	
	// Calculate additive genetic values for each individual based on the sum of their m2 mutations
	additive = inds.sumOfMutationsOfType(m2);
	
	// Calculate environmental values for each individual using a normal distribution with mean 0 and variance V_E
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// Calculate phenotype values for each individual as the sum of their additive genetic and environmental values
	phenotypes = additive + env;
	
	// Calculate fitness scaling for each individual based on their deviation from the target phenotype (newopt) 
	inds.fitnessScaling = 1 - (abs(phenotypes - newopt[sim.cycle])/200);
	// Get the mean fitness and phenotype and write them to a CSV file
	
	//mean_fitness =sum(ind.fitness(for(ind in inds))) / len(inds)
	mean_fitness = mean(inds.fitnessScaling);
	
	// Add the phenotypes as a tag to the individuals
	inds.tagF = phenotypes;
	
	// Get information about all mutations of type m2
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	
	// Calculate heterozygosity for each individual's genome
	het = calcHeterozygosity(p1.genomes);
	
	// Order mutations by frequency (descending) and output information for each mutation to a CSV file (genome_singl.csv)
	indices = order(freq, F);
	for (i in indices)
		writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/genome_singl.csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",",het, ",", origin[i]), append = T);
	
	// Calculate mean phenotype for the population
	meanPhenotype = mean(phenotypes);
	
	// Output information about mean phenotype and mean fitness to a CSV file (MeanPhenotypes_singl.csv)
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/MeanPhenotypes_singl.csv"), paste0(sim.cycle,",", mean_fitness,",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);

sim.outputFull("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Single_Pos/ped_file.csv");
}

// Define function to be called in the last 5 generations (500-505)
500:505 late() {
	// Output VCF file with all fixed mutations
	myg = p1.genomes;
	myg.outputVCF("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/Selection_Models/Single_Pos/sl_genome.vcf", outputMultiallelics = T, simplifyNucleotides = F);
	
	// Output information about fixed mutations to the SLiM console
	sim.outputFixedMutations();
}