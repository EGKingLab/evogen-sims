// set up a simple neutral simulation
initialize() {
	setSeed(12345);
	// 1st mutation which is neutral and its genomic element type 
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	
	scriptForQTLs = "rexp(1);";
	initializeMutationType("m2", 0.5, "s", scriptForQTLs);
	initializeGenomicElementType("g2", m2, 1.0);
	m2.convertToSubstitution = F;
	m2.mutationStackGroup = -1;
	m2.mutationStackPolicy = "l";
	m1.color = "green";
	m2.color = "red";
	//initializeSex("A");  //"A" is Autosomal while X would be sex chromosome
	
	//defining constants that will help us determin the QTLs position and the length of our chromosome.
	
	defineConstant("C", 100); // # of qtl position I want
	defineConstant("W", 5000); //# Neutal buffers for our QTLs
	pos = 0; //initial postion
	q = NULL;
	
	// Single chromosome of length 1Mb with uniform recombination
	for (i in 1:C) {
		initializeGenomicElement(g1, pos, pos + W-1); // #The first buffer before we get to our 1st QTL
		pos = pos + W; // This gives us the next length before we get to another QTL
		initializeGenomicElement(g2, pos, pos);
		q = c(q, pos);
		pos = pos + 1;
		initializeGenomicElement(g1, pos, pos + W-1); //g1 starts and ends the chromosome
		pos = pos + W;
	}
	defineConstant("Q", q); //remember our QTL positions
	initializeRecombinationRate(1e-8); //We're using a fixed recombiantion rate
}

1 early() {
	sim.addSubpop("p2", 2);
	g = p2.genomes[0];
	muts = g.addNewMutation(m2, rexp(100), Q);
	
	sim.addSubpop("p1", 10000);
	
	marks = runif(100, 0, 1);
	ind = 0;
	for(qpos in Q)
	{
		for(g in p1.genomes)
		{
			if(rbinom(1,1, marks[ind])==1){g.addMutations(muts[ind]);}
		}
		ind = ind + 1;
	}
	p2.setSubpopulationSize(0);
	
	writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/genome_test",".csv"), paste0("Generation,Position,Frequency,Effect, origin"));
	
	writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/MeanPhenotypes_test",".csv"), paste0("Generation,Phenotype,Optimum"));
}

/*1: early(){
	p1.setSexRatio(0.5);
	p1.setSelfingRate(0);
	p1.setCloningRate(c(0.0, 0.0));
}
*/

mutationEffect(m2) {
	return 1.0;
} //Neutral effect


/* since our fitness effect will depend on the phenotypes not selection coefficients, we will start saving the phenotypes here. Remember that SLiM tends to save at the end of final generation, while in our case we want the mean phenotype for each generatrion*/

1 late() {
	defineConstant("h2", 0.5);
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	V_A = sd(additive)^2;
	defineConstant("V_E",(V_A/h2)- V_A);    // from h2 == V_A / (V_A + V_E)
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	
	phenotypes = additive + env;
	
	/*	
	mh = mean(phenotypes) + sd(phenotypes)*4;
	ml = mean(phenotypes) + sd(phenotypes)*4;
	nopt = rep(c(rep(mh ,25),rep(ml,25)), 25);
	defineGlobal("newopt", nopt);
	
	*/
	
	nopt = runif(1001, mean(phenotypes) - (sd(phenotypes)*2), mean(phenotypes) + (sd(phenotypes)*2));
	defineGlobal("newopt", nopt);
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		//cat("   " + posit[i] + ": s = " + selCoef[i] + ", f == " + freq[i] + ", o == " + origin[i] + "\n");
		writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/genome_test",".csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",", origin[i]), append = T);
	
	meanPhenotype = mean(phenotypes);
	writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/MeanPhenotypes_test",".csv"), paste0(sim.cycle,",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);
}

2:1000 late() {
	// sum the additive effects of QTLs
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	// model environmental variance, according to the target heritability
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	phenotypes = additive + env;
	//inds.fitnessScaling = 1 + dnorm(newopt-phenotypes,0,0.25);
	//inds.fitnessScaling = (1 - abs(phenotypes - newopt[sim.cycle])/100);
	//inds.fitnessScaling = (phenotypes - abs(phenotypes - newopt[sim.cycle]));
	inds.fitnessScaling = (1 + (phenotypes - newopt[sim.cycle])/200);
	inds.tagF = phenotypes;
	
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		//cat("   " + posit[i] + ": s = " + selCoef[i] + ", f == " + freq[i] + ", o == " + origin[i] + "\n");
		writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/genome_test",".csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",", origin[i]), append = T);
	
	meanPhenotype = mean(p1.individuals.tagF);
	writeFile(paste0("/Users/ezra/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/code/test.dir/MeanPhenotypes_test",".csv"), paste0(sim.cycle,",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);
}

1000 late() {
	cat("\n\n-------------------------------\n");
	cat("QTLs at generation " + sim.cycle + ":\n\n");
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		cat("   " + posit[i] + ": selCoef = " + selCoef[i] + ", freq == " + freq[i] + ", origin == " + origin[i] + "\n");
	sim.simulationFinished();

}
