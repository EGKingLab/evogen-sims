// set up a simple neutral simulation
initialize() {
	setSeed(12345);
	// 1st mutation which is neutral and its genomic element type 
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	
	scriptForQTLs = "rexp(1);";
	initializeMutationType("m2", 0.5, "s", scriptForQTLs);
	initializeGenomicElementType("g2", m2, 1.0);
	m2.convertToSubstitution = F;
	//m2.mutationStackGroup = -1;
	m2.mutationStackPolicy = "l";
	m1.color = "green";
	m2.color = "red";
	
	//defining constants that will help us determin the QTLs position and the length of our chromosome.
	
	defineConstant("C", 100); // # of qtl I want
	defineConstant("W", 5000); //# Neutal buffers for our QTLs
	pos = 0; //initial postion
	q = NULL;
	
	// Single chromosome of length 1Mb with uniform recombination
	for (i in 1:C) {
		initializeGenomicElement(g1, pos, pos + W-1); // #The first buffer before we get to our 1st QTL
		pos = pos + W; // This gives us the next length before we get to another QTL
		initializeGenomicElement(g2, pos, pos);
		q = c(q, pos);
		pos = pos + 1;
		initializeGenomicElement(g1, pos, pos + W-1); //g1 starts and ends the chromosome
		pos = pos + W;
	}
	defineConstant("Q", q); //remember our QTL positions
	initializeRecombinationRate(1e-8); //We're using a fixed recombiantion rate
}

1 early() {
	sim.addSubpop("p2", 1);
	g = p2.genomes[0];
	
	//p1.genomes.addNewMutation(m2, rexp(70), sample(Q, 70));
	Yt = sample(Q, 40);
	defineGlobal("YT", Yt);
	muts = g.addNewMutation(m2, rexp(40), YT);
	//g.addMutations(muts);
	
	sim.addSubpop("p1", 10000);
	marks = runif(40, 0, 1);
	ind = 0;
	for(qpos in YT)
	{
		for(g in p1.genomes)
		{
			if(rbinom(1,1, marks[ind])== 1){g.addMutations(muts[ind]);}
		}
		ind = ind + 1;
	}
	p2.setSubpopulationSize(0);
	
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/genome_FSCP_WF.v5.csv"), paste0("Generation,Position,Frequency,Effect, origin"));
	
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/MeanPhenotypes_FSCP_WF.v5",".csv"), paste0("Generation,Phenotype,Optimum"));
}
/*
mutationEffect(m2) {
	return 1.0;
} //Neutral effect
*/
/* since our fitness effect will depend on the phenotypes not selection coefficients, we will start saving the phenotypes here. Remember that SLiM tends to save at the end of final generation, while in our case we want the mean phenotype for each generatrion*/

1 late() {
	defineConstant("h2", 0.5);
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	V_A = sd(additive)^2;
	defineConstant("V_E",(V_A/h2)- V_A);    // from h2 == V_A / (V_A + V_E)
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	phenotypes = additive + env;
	
	mh1 = mean(phenotypes) + sd(phenotypes);
	mh2 = mean(phenotypes) + sd(phenotypes)*2;
	mh3 = mean(phenotypes) + sd(phenotypes)*3;
	mh4 = mean(phenotypes) + sd(phenotypes)*4;
	nopt = rep(c(rep(mh1 ,25),rep(mh2,25),rep(mh3,25),rep(mh4,25)), 11);
	defineGlobal("newopt", nopt);
	
	/* inds.fitnessScaling = dnorm(optimum - phenotype, 0.0, 1.0); //1.0 + dexp(optimum - phenotype); Check Recipe 13.6 for more about fitness. Stabilizing, directional, disruptive, trancution, and squashed stabilizing selections
	inds.tagF = phenotypes;
	
	//REMEMBER THIS IN RECIPE 13.6 TRUNCATION SELECTION. This can help when you want to change selection at given generation
	
	To make this interesting, we need to build up some genetic diversity in QTLs first, so let's run
for 10000 ticks under neutral conditions first, with a population size of 5000, and then impose
truncation selection for the next 5000 ticks*/
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		//cat("   " + posit[i] + ": s = " + selCoef[i] + ", f == " + freq[i] + ", o == " + origin[i] + "\n");
		writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/genome_FSCP_WF.v5",".csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",", origin[i]), append = T);
	
	meanPhenotype = mean(phenotypes);
	
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/MeanPhenotypes_FSCP_WF.v5",".csv"), paste0(sim.cycle,",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);
}

2:1000 late() {
	// sum the additive effects of QTLs
	inds = sim.subpopulations.individuals;
	additive = inds.sumOfMutationsOfType(m2);
	
	// model environmental variance, according to the target heritability
	env = rnorm(size(inds), 0.0, sqrt(V_E));
	
	// set fitness effects and remember phenotypes
	phenotypes = additive + env;
	//cat(phenotypes + "\n");
	//inds.fitnessScaling = 1 + dnorm(newopt[sim.cycle]-phenotypes,0,0.25);
	//inds.fitnessScaling = 1 + ((phenotypes - newopt[sim.cycle])/200);
	//1.0 + dnorm(100 - phenotypes, 0.0, 5.0);
	inds.tagF = phenotypes;
	
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		//cat("   " + posit[i] + ": s = " + selCoef[i] + ", f == " + freq[i] + ", o == " + origin[i] + "\n");
		writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/genome_FSCP_WF.v5",".csv"), paste0(sim.cycle,",", posit[i], ",", format("%.6f",freq[i]), ",", format("%.6f",selCoef[i]), ",", origin[i]), append = T);
	
	meanPhenotype = mean(p1.individuals.tagF);
	writeFile(paste0("/Users/etb68/OneDrive - University of Missouri/Academics Mizzou (etb68@umsystem.edu)/Biologycal_Sciences/Research_Projects/Yeast_GitHub/evogen-sims/ET_Yeast/output.dir/DummyPop/WF_models/MeanPhenotypes_FSCP_WF.v5",".csv"), paste0(sim.cycle,",",format("%.6f", meanPhenotype),",", newopt[sim.cycle]), append=T);
}

1000 late() {
	cat("\n\n-------------------------------\n");
	cat("QTLs at generation " + sim.cycle + ":\n\n");
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		cat("   " + posit[i] + ": selCoef = " + selCoef[i] + ", freq == " + freq[i] + ", origin == " + origin[i] + "\n");
	sim.simulationFinished();
}