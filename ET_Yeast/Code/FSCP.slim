// set up a simple neutral simulation
initialize() {
	setSeed(12345);
	// 1st mutation which is neutral and its genomic element type 
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	
	scriptForQTLs = "rexp(1);";
	initializeMutationType("m2", 0.5, "s", scriptForQTLs);
	initializeGenomicElementType("g2", m2, 1.0);
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "l";
	m1.color = "yellow";
	m2.color = "red";
	//defining constants that will help us determin the QTLs position and the length of our chromosome.
	
	defineConstant("C", 100); // # of qtl I want
	defineConstant("W", 5000); //# Neutal buffers for our QTLs
	pos = 0; //initial postion
	q = NULL;
	
	// Single chromosome of length 1Mb with uniform recombination
	for (i in 1:C) {
		initializeGenomicElement(g1, pos, pos + W-1); // #The first buffer before we get to our 1st QTL
		pos = pos + W; // This gives us the next length before we get to another QTL
		initializeGenomicElement(g2, pos, pos);
		q = c(q, pos);
		pos = pos + 1;
		initializeGenomicElement(g1, pos, pos + W-1); //g1 starts and ends the chromosome
		pos = pos + W;
	}
	defineConstant("Q", q); //remember our QTL positions
	initializeRecombinationRate(1e-8); //We're using a fixed recombiantion rate
}
// create a population of 500 individuals
1 early() {
	sim.addSubpop("p1", 2000);
}
mutationEffect(m2) {
	return 1.0;
} //Neutral effect

/* since our fitness effect will depend on the phenotypes not selection coefficients, wwe will start saving the phenotypes here. Remember that SLiM tends to save at the end of final generation, while in our case we want the mean phenotype for each generatrion*/

1: late() {
	inds = sim.subpopulations.individuals;
	phenotype = inds.sumOfMutationsOfType(m2);
	optimum = 10.0;
	inds.fitnessScaling = dnorm(optimum - phenotype, 0.0, 1.0); //1.0 + dexp(optimum - phenotype);
	inds.tagF = phenotype;
}
1000000 late() {
	if (sim.cycle == 1)
		cat("mean phenotype:\n");
	meanPhenotype = mean(p1.individuals.tagF);
	cat(format("%.2f", meanPhenotype));
	
   cat("\n\n-------------------------------\n");
	cat("QTLs at cycle " + sim.cycle + ":\n\n");
	
	qtls = sim.mutationsOfType(m2);
	freq = sim.mutationFrequencies(NULL, qtls);
	selCoef = qtls.selectionCoeff;
	posit = qtls.position;
	origin = qtls.originTick;
	indices = order(freq, F);
	
	for (i in indices)
		cat("   " + posit[i] + ": s = " + selCoef[i] + ", f == " + freq[i] + ", o == " + origin[i] + "\n");
	
	sim.simulationFinished();
	}




// output samples of 10 genomes periodically, all fixed mutations at end
//1000 late() { p1.outputSample(10); }
//2000 late() { p1.outputSample(10); }
//2000 late() { sim.outputFixedMutations(); }
